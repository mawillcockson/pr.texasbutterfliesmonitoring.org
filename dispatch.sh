#!/bin/sh
set -eu
# To use this script, the following environment variables must be set
# - RENDER_REPOSITORY_TOKEN
# A personal access token with a scope "public_repo".
# Generate one here
# https://github.com/settings/tokens/new
# This token should be generated by a user with the ability to trigger
# workflow_dispatch events in the RENDER_REPOSITORY.
#
# - RENDER_REPOSITORY_TOKEN_USER
# The user the RENDER_REPOSITORY_TOKEN was generated by
#
# Additionally, these can be overridden by setting them in the calling
# environment
#
# The pull request number to request a preview of
PULL_REQUEST_ID="${PULL_REQUEST_ID:-"1"}"
export PULL_REQUEST_ID
# The URL used to confirm the preview is reachable
PREVIEW_URL="${PREVIEW_URL:-"https://pr.texasbutterfliesmonitoring.org/${PULL_REQUEST_ID}"}"
export PREVIEW_URL
# The repository that will run this script in a workflow
DISPATCH_REPOSITORY="${DISPATCH_REPOSITORY:-"mawillcockson/TXButterflies.github.io"}"
export DISPATCH_REPOSITORY
# The full payload of the github event
# Pull Request payload example:
# https://docs.github.com/en/developers/webhooks-and-events/webhook-events-and-payloads#pull_request
GITHUB_EVENT="${GITHUB_EVENT:-"$(jq --null-input --compact-output '{
    "action": "opened",
    "number": (env.PULL_REQUEST_ID),
    "pull_request": {
        "html_url": ("https://github.com/mawillcockson/TXButterflies.github.io/pull/" + env.PULL_REQUEST_ID),
        "number": (env.PULL_REQUEST_ID),
    },
    "repository": {
        "full_name": env.DISPATCH_REPOSITORY,
    },
}')"}"
export GITHUB_EVENT
# A git reference
# More info:
# https://docs.github.com/en/rest/reference/actions#create-a-workflow-dispatch-event
# This is required, but the renderer doesn't currently use it
GITHUB_REF="${GITHUB_REF:-"main"}"
export GITHUB_REF
# The username/repository of the GitHub repository that hosts the renderer
# workflow
RENDER_REPOSITORY="${RENDER_REPOSITORY:-"mawillcockson/pr.texasbutterfliesmonitoring.org"}"
export RENDER_REPOSITORY
# The number of seconds to wait for each step of building a website to complete
TIMEOUT_SEC="${TIMEOUT_SEC:-"120"}"
export TIMEOUT_SEC
# The number of seconds to wait between checking the status of each step of
# building a website
INTERVAL_SEC="${INTERVAL_SEC:-"10"}"
export INTERVAL_SEC
# The maximum time allowed for cURL to complete a request
CURL_TIMEOUT="${CURL_TIMEOUT:-"15"}"
export CURL_TIMEOUT


# If the environment variable 'CI' is not set, ask for the API token and
# username for the RENDER_REPOSITORY.
# Otherwise throw an error.
for VAR in "RENDER_REPOSITORY_TOKEN" "RENDER_REPOSITORY_TOKEN_USER"; do
    CURRENT_VAL="$(printenv "${VAR}" || printf '')"
    if [ -z "${CI+"unset"}" ]; then
        if [ -z "${CURRENT_VAL:+"unset"}" ]; then
            printf "%s: " "${var}"
            read "${var}"
            export "${var}"
        fi
    elif [ -z "${CURRENT_VAL-}" ]; then
        echo "environment variable '${VAR}' must be set"
        exit 1
    fi
done

log() {
    echo "$@"
}

set_output() {
    # See:
    # https://docs.github.com/en/actions/reference/workflow-commands-for-github-actions#setting-an-output-parameter
    printf '::set-output name=%s::%s\n' "$1" "$2"
}

set_env() {
    if [ -n "${CI+"set"}" ]; then
        printf '%s=%s\n' "$1" "$2" >> "${GITHUB_ENV}"
    else
        log "set_env '%s' '%s'" "$1" "$2"
    fi
}


# Collect initial state, for comparisons later
PRIOR_RENDER_RUN_JSON="$(curl \
    --max-time "${CURL_TIMEOUT}" \
    --request GET \
    --get \
    --header "Accept: application/vnd.github.v3+json" \
    --user "${GITHUB_TOKEN_USER}:${GITHUB_TOKEN}" \
    --url "https://api.github.com/repos/${RENDER_REPOSITORY}/actions/runs" \
    --data-urlencode "per_page=1")"
export PRIOR_RENDER_RUN_JSON
PRIOR_RENDER_RUN_ID="$(jq -nre 'env.PRIOR_RENDER_RUN_JSON | fromjson.workflow_runs[0].id')"
export PRIOR_RENDER_RUN_ID
log "PRIOR_RENDER_RUN_ID: '${PRIOR_RENDER_RUN_ID}'"

PRIOR_RENDER_GH_PAGES_COMMIT_JSON="$(curl \
    --max-time "${CURL_TIMEOUT}" \
    --request GET \
    --get \
    --header "Accept: application/vnd.github.v3+json" \
    --user "${RENDER_REPOSITORY_TOKEN_USER}:${RENDER_REPOSITORY_TOKEN}" \
    --url "https://api.github.com/repos/${RENDER_REPOSITORY}/commits" \
    --data-urlencode "sha=gh-pages" \
    --data-urlencode "per_page=1")"
export PRIOR_RENDER_GH_PAGES_COMMIT_JSON
PRIOR_RENDER_GH_PAGES_COMMIT_SHA="$(jq -nre 'env.PRIOR_RENDER_GH_PAGES_COMMIT_JSON | fromjson[0].sha')"
export PRIOR_RENDER_GH_PAGES_COMMIT_SHA
log "PRIOR_RENDER_GH_PAGES_COMMIT_SHA: '${PRIOR_RENDER_GH_PAGES_COMMIT_SHA}'"

PRIOR_RENDER_DEPLOYMENT_JSON="$(curl \
    --max-time "${CURL_TIMEOUT}" \
    --request GET \
    --get \
    --header "Accept: application/vnd.github.v3+json" \
    --user "${GITHUB_TOKEN_USER}:${GITHUB_TOKEN}" \
    --url "https://api.github.com/repos/${RENDER_REPOSITORY}/deployments" \
    --data-urlencode "per_page=1")"
export PRIOR_RENDER_DEPLOYMENT_JSON
PRIOR_RENDER_DEPLOYMENT_ID="$(jq -nre 'env.PRIOR_RENDER_DEPLOYMENT_JSON | fromjson[0].id')"
export PRIOR_RENDER_DEPLOYMENT_ID
log "PRIOR_RENDER_DEPLOYMENT_ID: '${PRIOR_RENDER_DEPLOYMENT_ID}'"
# This run
DISPATCH_RUN_JSON="$(curl \
    --max-time "${CURL_TIMEOUT}" \
    --request GET \
    --get \
    --header "Accept: application/vnd.github.v3+json" \
    --user "${GITHUB_TOKEN_USER}:${GITHUB_TOKEN}" \
    --url "https://api.github.com/repos/${DISPATCH_REPOSITORY}/actions/runs" \
    --data-urlencode "per_page=1")"
export DISPATCH_JSON
DISPATCH_CHECK_SUITE_ID="$(jq -nre 'env.DISPATCH_RUN_JSON | fromjson.workflow_runs[0].check_suite_id')"
export DISPATCH_CHECK_SUITE_ID
DISPATCH_CHECK_RUN_URL="https://api.github.com/repos/${DISPATCH_REPOSITORY}/check-suites/${DISPATCH_CHECK_SUITE_ID}/check-runs"
export DISPATCH_CHECK_RUN_URL
DISPATCH_CHECK_RUN_JSON="$(curl \
    --max-time "${CURL_TIMEOUT}" \
    --request GET \
    --header "Accept: application/vnd.github.v3+json" \
    --user "${GITHUB_TOKEN_USER}:${GITHUB_TOKEN}" \
    --url "${DISPATCH_CHECK_RUN_URL}")"
export DISPATCH_CHECK_RUN_JSON
DISPATCH_LOG_URL="$(jq -nre 'env.DISPATCH_CHECK_RUN_JSON | fromjson.check_runs |
    map(select(.check_suite.id == env.DISPATCH_CHECK_SUITE_ID and (.name | test("^dispatch"; "i")))) | first.details_url')"
export DISPATCH_LOG_URL
set_output "DISPATCH_LOG_URL" "${DISPATCH_LOG_URL}"


# Dispatch preview render job
DISPATCH_PAYLOAD="$(jq --null-input --compact-output '{
    "ref": (env.GITHUB_REF),
    "inputs": {
        "pull_request_id": (env.GITHUB_EVENT | fromjson.pull_request.number),
        "pull_request_event": env.GITHUB_EVENT
    }
}')"
export DISPATCH_PAYLOAD
log "DISPATCH_PAYLOAD: '${DISPATCH_PAYLOAD}'"

curl \
    --max-time "${CURL_TIMEOUT}" \
    --request POST \
    --header "Accept: application/vnd.github.v3+json" \
    --user "${RENDER_REPOSITORY_TOKEN_USER}:${RENDER_REPOSITORY_TOKEN}" \
    --post301 --post302 --post303 \
    --data "${DISPATCH_PAYLOAD}" \
    --url "https://api.github.com/repos/${RENDER_REPOSITORY}/actions/workflows/pull_request.yaml/dispatches"


# Find the GitHub Actions run that the dispatch triggered in the
# RENDER_REPOSITORY
MOST_RECENT_RENDER_RUN_JSON="$(curl \
    --max-time "${CURL_TIMEOUT}" \
    --request GET \
    --get \
    --header "Accept: application/vnd.github.v3+json" \
    --user "${GITHUB_TOKEN_USER}:${GITHUB_TOKEN}" \
    --url "https://api.github.com/repos/${RENDER_REPOSITORY}/actions/runs" \
    --data-urlencode "per_page=1")"
export MOST_RECENT_RENDER_RUN_JSON
MOST_RECENT_RENDER_RUN_ID="$(jq -nre 'env.MOST_RECENT_RENDER_RUN_JSON | fromjson.workflow_runs[0].id')"
export MOST_RECENT_RENDER_RUN_ID
log "MOST_RECENT_RENDER_RUN_ID: '${MOST_RECENT_RENDER_RUN_ID}'"

# If it wasn't found, wait until it's created
TIMEOUT_DATE="$(( $(date +%s) + TIMEOUT_SEC ))"
export TIMEOUT_DATE

while [ "${PRIOR_RENDER_RUN_ID}" = "${MOST_RECENT_RENDER_RUN_ID}" ]; do
    if [ "$(date +%s)" -gt "${TIMEOUT_DATE}" ]; then
        echo "Timeout exceeded while waiting for dispatch to add a job to the queue"
        set_output "DISPATCH_RESULT" "dispatch_timeout"
        exit 0
    fi
    sleep "${INTERVAL_SEC}"

    MOST_RECENT_RENDER_RUN_JSON="$(curl \
        --max-time "${CURL_TIMEOUT}" \
        --request GET \
        --get \
        --header "Accept: application/vnd.github.v3+json" \
        --user "${GITHUB_TOKEN_USER}:${GITHUB_TOKEN}" \
        --url "https://api.github.com/repos/${RENDER_REPOSITORY}/actions/runs" \
        --data-urlencode "per_page=1")"
    MOST_RECENT_RENDER_RUN_ID="$(jq -nre 'env.MOST_RECENT_RENDER_RUN_JSON | fromjson.workflow_runs[0].id')"
done

# It was found
log "MOST_RECENT_RENDER_RUN_JSON: '${MOST_RECENT_RENDER_RUN_JSON}'"

# Make sure it's a workflow_dispatch event, since that's what's created by the
# dispatch sent earlier
if ! jq -nre 'env.MOST_RECENT_RENDER_RUN_JSON | fromjson.workflow_runs[0].event == "workflow_dispatch"'; then
    echo "Most recent workflow run is not a workflow_dispatch"
    set_output "DISPATCH_RESULT" "dispatch_error"
    exit 0
fi


# Find the human-readable HTML URL for the render run
RENDER_RUN_URL="$(jq -nre 'env.MOST_RECENT_RENDER_RUN_JSON | fromjson.workflow_runs[0].url')"
export RENDER_RUN_URL
log "RENDER_RUN_URL: '${RENDER_RUN_URL}'"

render_run_json() {
    curl \
        --max-time "${CURL_TIMEOUT}" \
        --request GET \
        --header "Accept: application/vnd.github.v3+json" \
        --user "${GITHUB_TOKEN_USER}:${GITHUB_TOKEN}" \
        --url "${RENDER_RUN_URL}"
}

# Wait while the job run is queued
RENDER_RUN_JSON="$(render_run_json)"
export RENDER_RUN_JSON
RENDER_CHECK_SUITE_ID="$(jq -nre 'env.RENDER_RUN_JSON | fromjson.check_suite_id')"
export RENDER_CHECK_SUITE_ID
RENDER_RUN_JSON="$(curl \
    --max-time "${CURL_TIMEOUT}" \
    --request GET \
    --get \
    --header "Accept: application/vnd.github.v3+json" \
    --user "${GITHUB_TOKEN_USER}:${GITHUB_TOKEN}" \
    --url "https://api.github.com/repos/${RENDER_REPOSITORY}/actions/runs" \
    --data-urlencode "per_page=1")"
export RENDER_RUN_JSON
RENDER_CHECK_SUITE_ID="$(jq -nre 'env.RENDER_RUN_JSON | fromjson.workflow_runs[0].check_suite_id')"
export RENDER_CHECK_SUITE_ID
RENDER_CHECK_RUN_URL="https://api.github.com/repos/${RENDER_REPOSITORY}/check-suites/${RENDER_CHECK_SUITE_ID}/check-runs"
export RENDER_CHECK_RUN_URL
log "RENDER_CHECK_RUN_URL: '${RENDER_CHECK_RUN_URL}'"
RENDER_CHECK_RUN_JSON="$(curl \
    --max-time "${CURL_TIMEOUT}" \
    --request GET \
    --header "Accept: application/vnd.github.v3+json" \
    --user "${GITHUB_TOKEN_USER}:${GITHUB_TOKEN}" \
    --url "${RENDER_CHECK_RUN_URL}")"
export RENDER_CHECK_RUN_JSON
RENDER_LOG_URL="$(jq -nre 'env.RENDER_CHECK_RUN_JSON | fromjson.check_runs |
    map(select(.check_suite.id == env.RENDER_CHECK_SUITE_ID and (.name | test("^build"; "i")))) | first.details_url')"
export RENDER_LOG_URL
set_output "RENDER_LOG_URL" "${RENDER_LOG_URL}"


# Check the status of the render run, to see if that job has been queued, is
# running, or has been completed
RENDER_RUN_STATUS="$(jq -nre 'env.RENDER_RUN_JSON | fromjson.status')"
export RENDER_RUN_STATUS
log "RENDER_RUN_STATUS: '${RENDER_RUN_STATUS}'"

TIMEOUT_DATE="$(( $(date +%s) + TIMEOUT_SEC ))"

# Wait while the job is queued
while [ "${RENDER_RUN_STATUS}" = "queued" ]; do
    if [ "$(date +%s)" -gt "${TIMEOUT_DATE}" ]; then
        echo "Timeout exceeded while waiting for job to run"
        set_output "DISPATCH_RESULT" "queue_timeout"
        exit 0
    fi
    sleep "${INTERVAL_SEC}"

    RENDER_RUN_JSON="$(render_run_json)"
    RENDER_RUN_STATUS="$(jq -nre 'env.RENDER_RUN_JSON | fromjson.status')"
    log "RENDER_RUN_STATUS: '${RENDER_RUN_STATUS}'"
done

# Wait while the job run is running
TIMEOUT_DATE="$(( $(date +%s) + TIMEOUT_SEC ))"

while [ "${RENDER_RUN_STATUS}" = "in_progress" ]; do
    if [ "$(date +%s)" -gt "${TIMEOUT_DATE}" ]; then
        echo "Timeout exceeded while waiting for job to finish running"
        set_output "DISPATCH_RESULT" "run_timeout"
        exit 0
    fi
    sleep "${INTERVAL_SEC}"

    RENDER_RUN_JSON="$(render_run_json)"
    RENDER_RUN_STATUS="$(jq -nre 'env.RENDER_RUN_JSON | fromjson.status')"
    log "RENDER_RUN_STATUS: '${RENDER_RUN_STATUS}'"
done

# GitHub Actions render workflow has been run, check status and conclustion
if [ "$(jq -nre 'env.RENDER_RUN_JSON | fromjson.status')" != "completed" ]; then
    set_output "DISPATCH_RESULT" "run_error"
    exit 0
elif [ "$(jq -nre 'env.RENDER_RUN_JSON | fromjson.conclusion')" != "success" ]; then
    set_output "DISPATCH_RESULT" "run_failed"
    exit 0
fi

# GitHub Actions Run completed, and was successful.
# Now check that a commit was made to the gh-pages branch of the
# RENDER_REPOSITORY.
RENDER_GH_PAGES_COMMIT_JSON="$(curl \
    --max-time "${CURL_TIMEOUT}" \
    --request GET \
    --get \
    --header "Accept: application/vnd.github.v3+json" \
    --user "${RENDER_REPOSITORY_TOKEN_USER}:${RENDER_REPOSITORY_TOKEN}" \
    --url "https://api.github.com/repos/${RENDER_REPOSITORY}/commits" \
    --data-urlencode "sha=gh-pages" \
    --data-urlencode "per_page=1")"
export RENDER_GH_PAGES_COMMIT_JSON
RENDER_GH_PAGES_COMMIT_SHA="$(jq -nre 'env.RENDER_GH_PAGES_COMMIT_JSON | fromjson[0].sha')"
export RENDER_GH_PAGES_COMMIT_SHA
log "RENDER_GH_PAGES_COMMIT_SHA: '${RENDER_GH_PAGES_COMMIT_SHA}'"

TIMEOUT_DATE="$(( $(date +%s) + TIMEOUT_SEC ))"

# If the commit hasn't shown up yet, wait for it
while [ "${PRIOR_RENDER_GH_PAGES_COMMIT_SHA}" = "${RENDER_GH_PAGES_COMMIT_SHA}" ]; do
    if [ "$(date +%s)" -gt "${TIMEOUT_DATE}" ]; then
        echo "The build run succeeded, but a commit has not yet been made to the gh-pages branch of '${RENDER_REPOSITORY}'"
        set_output "DISPATCH_RESULT" "commit_timeout"
        exit 0
    fi
    sleep "${INTERVAL_SEC}"

    RENDER_GH_PAGES_COMMIT_JSON="$(curl \
        --max-time "${CURL_TIMEOUT}" \
        --request GET \
        --get \
        --header "Accept: application/vnd.github.v3+json" \
        --user "${RENDER_REPOSITORY_TOKEN_USER}:${RENDER_REPOSITORY_TOKEN}" \
        --url "https://api.github.com/repos/${RENDER_REPOSITORY}/commits" \
        --data-urlencode "sha=gh-pages" \
        --data-urlencode "per_page=1")"
    RENDER_GH_PAGES_COMMIT_SHA="$(jq -nre 'env.RENDER_GH_PAGES_COMMIT_JSON | fromjson[0].sha')"
    log "RENDER_GH_PAGES_COMMIT_SHA: '${RENDER_GH_PAGES_COMMIT_SHA}'"
done

# A commit was made to the gh-pages branch
# Now check deployment
RENDER_DEPLOYMENT_JSON="$(curl \
    --max-time "${CURL_TIMEOUT}" \
    --request GET \
    --header "Accept: application/vnd.github.v3+json" \
    --user "${GITHUB_TOKEN_USER}:${GITHUB_TOKEN}" \
    --url "https://api.github.com/repos/${RENDER_REPOSITORY}/deployments")"
export RENDER_DEPLOYMENT_JSON
RENDER_DEPLOYMENT_ID="$(jq -nre 'env.RENDER_DEPLOYMENT_JSON | fromjson[0].id')"
export RENDER_DEPLOYMENT_ID
log "RENDER_DEPLOYMENT_ID: '${RENDER_DEPLOYMENT_ID}'"

TIMEOUT_DATE="$(( $(date +%s) + TIMEOUT_SEC ))"

while [ "${PRIOR_RENDER_DEPLOYMENT_ID}" = "${RENDER_DEPLOYMENT_ID}" ]; do
    if [ "$(date +%s)" -gt "${TIMEOUT_DATE}" ]; then
        echo "Timeout exceeded while waiting for GitHub Pages to make a new deployment"
        set_output "DISPATCH_RESULT" "deploy_timeout"
        exit 0
    fi
    sleep "${INTERVAL_SEC}"

    RENDER_DEPLOYMENT_JSON="$(curl \
        --max-time "${CURL_TIMEOUT}" \
        --request GET \
        --header "Accept: application/vnd.github.v3+json" \
        --user "${GITHUB_TOKEN_USER}:${GITHUB_TOKEN}" \
        --url "https://api.github.com/repos/${RENDER_REPOSITORY}/deployments")"
    RENDER_DEPLOYMENT_ID="$(jq -nre 'env.RENDER_DEPLOYMENT_JSON | fromjson[0].id')"
    log "RENDER_DEPLOYMENT_ID: '${RENDER_DEPLOYMENT_ID}'"
done

# Deployment finished
# Verify website is reachable
preview_http_status() {
    curl \
        --max-time "${CURL_TIMEOUT}" \
        --request HEAD \
        --fail \
        --silent \
        --show-error \
        --location \
        --head \
        --header 'Cache-Control: no-store' \
        --header 'Pragma: no-cache' \
        --url "${PREVIEW_URL}" \
        --output /dev/null \
        --write-out '%{http_code}'
}
PREVIEW_HTTP_STATUS_CODE="$(preview_http_status)"
export PREVIEW_HTTP_STATUS_CODE
log "PREVIEW_HTTP_STATUS_CODE: '${PREVIEW_HTTP_STATUS_CODE}'"

TIMEOUT_DATE="$(( $(date +%s) + TIMEOUT_SEC ))"

while [ "${PREVIEW_HTTP_STATUS_CODE}" -eq "404" ]; do
    if [ "$(date +%s)" -gt "${TIMEOUT_DATE}" ]; then
        echo "Timeout exceeded while waiting for the preview website to return something other than a 404"
        set_output "DISPATCH_RESULT" "http_status_timeout"
        exit 0
    fi
    sleep "${INTERVAL_SEC}"

    PREVIEW_HTTP_STATUS_CODE="$(preview_http_status)"
    log "PREVIEW_HTTP_STATUS_CODE: '${PREVIEW_HTTP_STATUS_CODE}'"
done

# Verify it's a 200 HTTP status code
if [ "${PREVIEW_HTTP_STATUS_CODE}" -ne "200" ]; then
    echo "The preview website '${PREVIEW_URL}' is returning a status code of '${PREVIEW_HTTP_STATUS_CODE}'"
    set_output "DISPATCH_RESULT" "http_status_failure"
    exit 0
fi

# Everything succeeded
set_output "DISPATCH_RESULT" "all_success"
exit 0
